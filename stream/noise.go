// {{{ Copyright (c) Paul R. Tagliamonte <paul@k3xec.com>, 2020
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE. }}}

package stream

import (
	"math/rand"

	"hz.tools/sdr"
)

// NoiseConfig will dictate the type of noise generated by the Noise reader.
type NoiseConfig struct {
	// Source will provide a RNG for use by the Noise reader to generate
	// normally distributed noise.
	Source rand.Source

	// SampleRate is a *required* param if any code will be consuming this
	// reader. This will (unhelpfully!) default to 0, which is a massive
	// consistency issue. This value should be set to something sensible!
	SampleRate uint

	// StandardDeviation will control how wide the Standard Deviation of values
	// produced by this function is.
	//
	// If left at 0, this will be set to a sensible value for normal amounts
	// of noise encountered during real life.
	StandardDeviation float64

	// Mean is not currently in here, but would be welcome if someone
	// has a use-case for it (likely something eventually)
	// Mean float64
}

type noiseReader struct {
	sampleRate uint
	rand       *rand.Rand
	stdDev     float64
}

func (nr *noiseReader) SampleFormat() sdr.SampleFormat {
	return sdr.SampleFormatC64
}

func (nr *noiseReader) SampleRate() uint {
	return nr.sampleRate
}

func (nr *noiseReader) nextSample() complex64 {
	return complex(
		clampRealToRange(float32(nr.rand.NormFloat64()*nr.stdDev), -1.0, 1.0),
		clampRealToRange(float32(nr.rand.NormFloat64()*nr.stdDev), -1.0, 1.0),
	)
}

func (nr *noiseReader) Read(s sdr.Samples) (int, error) {
	switch s.Format() {
	case sdr.SampleFormatC64:
		break
	default:
		return 0, sdr.ErrSampleFormatMismatch
	}

	// TODO(paultag): make this safer? Support additional types?
	samples := s.(sdr.SamplesC64)

	for i := range samples {
		samples[i] = nr.nextSample()
	}

	return len(samples), nil
}

// Noise will generate a sdr.Reader of gaussian noise. The params
// controlling the range and distribution of the noise are passed in via
// NoiseConfig. If no values are set, "sensible" defaults are created.
//
// This function is intended for debugging and development - production
// use should be carefully considered, and likely trigger a conversation
// with the maintainers regarding your use-case and how to ensure this
// function is correct.
func Noise(nc NoiseConfig) sdr.Reader {

	// TODO(paultag): sanity check values here

	if nc.Source == nil {
		// TODO(paultag): use the process PID mixed with time or something?
		nc.Source = rand.NewSource(1024)
	}

	if nc.StandardDeviation == 0 {
		// roughly 1/255
		nc.StandardDeviation = 0.04
	}

	return &noiseReader{
		rand:       rand.New(nc.Source),
		stdDev:     nc.StandardDeviation,
		sampleRate: nc.SampleRate,
	}
}

// NoisyReader will pass along data from an underlying reader but with
// some added noise on top.
//
// SNR represents the signal to noise ratio. The SNR param is a float
// that represents the amount of noise added to the provided signal from 0
// (no noise) to 1 (100% noise).
func NoisyReader(nc NoiseConfig, r sdr.Reader, snr float32) (sdr.Reader, error) {
	nc.SampleRate = r.SampleRate()
	nr := Gain(Noise(nc), 1.0-snr)
	return Add(Gain(r, snr), nr)
}

func clampRealToRange(v, min, max float32) float32 {
	switch {
	case v < min:
		return min
	case v > max:
		return max
	default:
		return v
	}
}

// vim: foldmethod=marker
